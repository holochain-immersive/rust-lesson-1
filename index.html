<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name="Description" content="Put your description here."><base href="/"><style>body,html{margin:0;padding:0;font-family:sans-serif;background-color:#ededed;--r-main-font-size:24px;--r-heading-margin:20px 0 12px 0}.slides{width:75%!important}.container{top:0!important;display:flex!important;flex-direction:row!important}.column{flex:1}section{text-align:left}.popover{position:absolute;background-color:#4d4d4d;padding:1rem 2rem;box-shadow:0 2px 5px 0 rgba(0,0,0,.26);border-radius:10px;width:auto;transform:translate(35px,-15px)}.popover:after{content:"";position:absolute;top:6px;left:-10px;border-style:solid;border-width:25px 25px 0;border-color:#4d4d4d transparent;display:block;width:0;z-index:1;transform:translate(-50%,50%) rotate(90deg)}.reveal pre code{max-height:800px!important}</style><link rel="stylesheet" href="lesson-1/bce6cb85.css"><link rel="stylesheet" href="lesson-1/5265d60d.css"><link rel="stylesheet" href="lesson-1/86125abe.css"><title>Lesson 1</title></head><body><div class="reveal"><div class="slides"><section><h1>Rust Language Fundamentals</h1></section><section><h2>Why Rust?</h2><div class="container"><div class="column"><h3>A low level language</h3><li class="fragment fade-in-then-semi-out">Compiled, not interpreted</li><li class="fragment fade-in-then-semi-out">Enforces very strict rules</li><li class="fragment fade-in-then-semi-out">Goal: all errors at compile time</li><li class="fragment fade-in-then-semi-out">No segmentation faults</li><li class="fragment fade-in-then-semi-out">Semi-optimal garbage collection</li></div><div class="column"><h3 class="fragment fade-in">Modern &amp; high level features</h3><li class="fragment fade-in-then-semi-out">Great compiler &amp; error messages</li><li class="fragment fade-in-then-semi-out">Iterators</li><li class="fragment fade-in-then-semi-out">Functional programming features<ul><li class="fragment fade-in-then-semi-out">Function pointers &amp; closures</li><li class="fragment fade-in-then-semi-out">Higher order functions</li></ul></li><li class="fragment fade-in-then-semi-out">Package manager</li><li class="fragment fade-in-then-semi-out">Testing framework</li></div></div></section><section><h3>Variable Consumption</h3><li class="fragment fade-in-then-semi-out">One of Rust's most distinctive features</li><li class="fragment fade-in-then-semi-out">Allows the compiler to prevent many kinds of error</li><li class="fragment fade-in-then-semi-out">A constraint on how you write code</li><li class="fragment fade-in-then-semi-out">When you reference certain variables, they become "consumed"</li><li class="fragment fade-in-then-semi-out">A consumed variable cannot be referenced again later</li></section><section><h3>Categories of Typed Variables</h3><h4 class="fragment fade-in-then-semi-out">Scalars (unconsumable)</h4><li class="fragment fade-in-then-semi-out">Boolean</li><li id="integer" class="fragment fade-in-then-semi-out">Integer<ul data-fragment-skip="" class="popover fragment fade-in-then-out"><li class="fragment fade-in-then-semi-out">Unsigned<ul><li class="fragment fade-in-then-semi-out">u8 through u64</li><li class="fragment fade-in-then-semi-out">usize (based on machine architecture)</li></ul></li><li class="fragment fade-in-then-semi-out">Signed<ul><li class="fragment fade-in-then-semi-out">i8 through i64</li><li class="fragment fade-in-then-semi-out">isize (based on machine architecture)</li></ul></li><li class="fragment fade-in-then-semi-out">Extra credit<ul><li class="fragment fade-in-then-semi-out">Other base systems (binary, hex, octal)</li></ul></li></ul></li><li class="fragment fade-in-then-semi-out">Float<ul data-fragment-skip="" class="popover fragment fade-in-then-out"><li class="fragment fade-in-then-semi-out">Signed<ul><li class="fragment fade-in-then-semi-out">f32 and f64</li><li class="fragment fade-in-then-semi-out">Default is f64</li></ul></li></ul></li><li class="fragment fade-in-then-semi-out">Char<ul data-fragment-skip="" class="popover fragment fade-in-then-out"><li class="fragment">A char literal is surrounded by single quotes</li></ul></li><li class="fragment fade-in-then-semi-out">Unit type</li><li class="fragment fade-in-then-semi-out">Str literal*<ul data-fragment-skip="" class="popover fragment fade-in-then-out"><li class="fragment">Fundamentally immutable</li></ul></li><h4 class="fragment fade-in-then-semi-out">Unconsumable Compounds</h4><ul><li class="fragment fade-in-then-semi-out">Tuple of unconsumables</li><li class="fragment fade-in-then-semi-out">Array of unconsumables</li></ul><h4 class="fragment fade-in-then-semi-out">Consumable Compounds</h4><ul><li class="fragment fade-in-then-semi-out">Tuple of consumables</li><li class="fragment fade-in-then-semi-out">Array of consumables</li><li class="fragment fade-in-then-semi-out">Structs<ul><li class="fragment fade-in-then-semi-out">Vectors</li><li class="fragment fade-in-then-semi-out">String struct</li></ul></li><li class="fragment fade-in-then-semi-out">Enums</li></ul></section><section><h3>Declaration of Variables</h3><pre><code class="rust" data-noescape=""><span class="fragment fade-in-then-semi-out">// Declare with "let", in snake case
let user_age: f32 = 1.0;
</span>

<span class="fragment fade-in-then-semi-out">// Redeclaration
let user_age: f32 = 2.0;</span>

<span class="fragment fade-in-then-semi-out">
// (type is inferred if omitted)
let user_age = 3.0; // Default type: f64</span>
  
<span class="fragment fade-in-then-semi-out">// Immutable by default
<span class="fragment strike">user_age = 4.0;</span> // Err</span>

<span class="fragment fade-in-then-semi-out">// Set as mutable
let mut mutable_age = 5;
mutable_age = 6; // Works</span>

<span class="fragment fade-in-then-semi-out">// Strict Typing
<span class="fragment strike">mutable_age = “seven”;</span> // Err</span>
            </code></pre></section><section><h3>Conditional Blocks</h3><pre><code class="rust" data-noescape="">let n = 1;

<span class="fragment fade-in-then-semi-out">// No parenthesis
// Boolean expression
if n == 1 {
  // Conditional block
}</span>

<span class="fragment fade-in-then-semi-out">// Logical operators
if n &gt; 0 || !(n &lt;= 2 &amp;&amp; n != 3) {
  // Conditional block 
}</span>
  
<span class="fragment fade-in-then-semi-out">
if n &gt; 0 {
  // If
} else if n &lt; 2 {
  // Else if, can be repeated
} else {
  // Else
}</span>

<span class="fragment fade-in-then-semi-out">// Can have a result value
let if_result: u32 = if n &lt; 2 {
  // Last block line is an expression
  2
} else {
  let y = 3;
  // Last block line is an expression 
  y
}; // Notice the semi-colon</span>            
            </code></pre></section><section><h3>Iteration Blocks</h3><pre><code class="rust" data-noescape="">let mut i = 0;

<span class="fragment fade-in-then-semi-out">// "while" with boolean expression
while i &lt; 3 {
  i += 1;
}</span>

<span class="fragment fade-in-then-semi-out">// Can't have a result value
<span class="fragment strike">let result = while i &lt; 3 {
  4
};</span></span>
  
<span class="fragment fade-in-then-semi-out">// "break" stops the loop
while i &lt; 3 {
  if i == 2 {
    break;
  }
}
// i will be 2</span>

<span class="fragment fade-in-then-semi-out">// "for" loop with excluding range
for i in 0..3 {
  // i will be 0, 1, 2
}</span>

<span class="fragment fade-in-then-semi-out">// "for" loop with including range
for i in 0..=3 {
  // i will be 0, 1, 2, 3
}</span>
</code></pre></section><section><h3>Functions</h3><pre><code class="rust" data-noescape=""><span class="fragment fade-in-then-semi-out">// All parameter types declared
fn add(a: u32, b: u32) -&gt; u32 {
  return a + b;
}</span>

<span class="fragment fade-in-then-semi-out">// Return is implied if last line is an expression
fn add_expr(a: u32, b: u32) -&gt; u32 {
  a + b
}</span>

<span class="fragment fade-in-then-semi-out">// Unit type is implied if there is no return
fn no_return() -&gt; () {
  ()
}
fn equivalent_to_no_return() {

}</span>

<span class="fragment fade-in-then-semi-out">// Functions can be stored in functions pointers
fn higher_order() {
  let add_fn: fn(u32, u32) -&gt; u32 = add;
}</span>
          </code></pre></section><section><h3>Closures</h3><li class="fragment fade-in-then-semi-out">Functions that capture their environment</li><pre><code class="rust" data-noescape=""><span class="fragment fade-in-then-semi-out">
fn sample() {
  <span class="fragment fade-in-then-semi-out">// Parmeters inside | |
  let equal_to_4 = |z: u32| {
    z == x  // x is captured
  };</span>

  <span class="fragment fade-in-then-semi-out">// Closures are invoked like functions
  let is_four_a = equal_to_4(4); // true
  let is_four_b = equal_to_4(5); // false</span>

  <span class="fragment fade-in-then-semi-out">let x: u32 = 4;
  // They capture their environment
  let equal_to_x = |z: u32| {
    z == x  // x is captured
  };

  let is_four_a = equal_to_x(4); // true
  let is_four_b = equal_to_x(5); // false</span>

  <span class="fragment fade-in-then-semi-out">// Parameter types can be inferred
  let equal_to_x_infer = |z| { // z is of type u32 
    z == x
  };</span>

  <span class="fragment fade-in-then-semi-out">// Body can be just an returning expression
  let equal_to_x_simple = |z| z == x;</span>

  <span class="fragment fade-in-then-semi-out">// Can't be sent to another context
  <span class="fragment strike">return equal_to_4;</span>// Err</span>
}</span>
          </code></pre></section><section><h3>String Literal</h3><pre><code class="rust" data-noescape=""><span class="fragment fade-in-then-semi-out">// &amp;str
let s: &amp;str = "hello world!";</span>

<span class="fragment fade-in-then-semi-out">// str is not valid
<span class="fragment strike">let s: str = "hello world!";</span> // Err</span>

<span class="fragment fade-in-then-semi-out">// Fundamentally immutable
<span class="fragment strike">let mut s: &amp;str = "hello world!";</span> // Err</span>

<span class="fragment fade-in-then-semi-out">// Copyable
let s: &amp;str = "hello world!";
let x = s;
let y = s; // Ok</span>

<span class="fragment fade-in-then-semi-out">// Sliceable
let s: &amp;str = "hello world!";
let slice: &amp;str = &amp;s[0..2]; // "slice" will contain "he" 
                            // Notice the &amp;</span>

<span class="fragment fade-in-then-semi-out">// Does not support indexing
let s: &amp;str = "hello world!";
<span class="fragment strike">let first_char = s[0];</span> // Err</span>  
</code></pre></section><section><h3>String Literal</h3><pre><code class="rust" data-noescape=""><span class="fragment fade-in-then-semi-out">// &amp;str
let s: &amp;str = "hello world!";</span>

<span class="fragment fade-in-then-semi-out">// str is not valid
<span class="fragment strike">let s: str = "hello world!";</span> // Err</span>

<span class="fragment fade-in-then-semi-out">// Fundamentally immutable
<span class="fragment strike">let mut s: &amp;str = "hello world!";</span> // Err</span>

<span class="fragment fade-in-then-semi-out">// Copyable
let s: &amp;str = "hello world!";
let x = s;
let y = s; // Ok</span>

<span class="fragment fade-in-then-semi-out">// Sliceable
let s: &amp;str = "hello world!";
let slice: &amp;str = &amp;s[0..2]; // "slice" will contain "he" 
                            // Notice the &amp;</span>

<span class="fragment fade-in-then-semi-out">// Does not support indexing
let s: &amp;str = "hello world!";
<span class="fragment strike">let first_char = s[0];</span> // Err</span>  
</code></pre></section></div></div><script type="module" src="./lesson-1/f97af496.js"></script></body></html>